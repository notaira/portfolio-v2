"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.equivalentZones = exports.extractTzOffsetFromUTCOffset = exports.inferLikelyOffsetMinutes = exports.extractTzOffsetFromTags = exports.extractOffset = exports.offsetMinutesToZoneName = exports.reasonableTzOffsetMinutes = exports.normalizeZone = exports.defaultVideosToUTC = exports.UnsetZoneName = exports.UnsetZone = exports.UnsetZoneOffsetMinutes = exports.MaxTzOffsetHours = void 0;
const luxon_1 = require("luxon");
const Array_1 = require("./Array");
const CapturedAtTagNames_1 = require("./CapturedAtTagNames");
const ExifDateTime_1 = require("./ExifDateTime");
const Maybe_1 = require("./Maybe");
const Number_1 = require("./Number");
const String_1 = require("./String");
// Pacific/Kiritimati is +14:00 TIL
// https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
exports.MaxTzOffsetHours = 14;
/**
 * Zone instances with this offset are a placeholder for being "unset".
 */
exports.UnsetZoneOffsetMinutes = -1;
/**
 * This is a placeholder for dates where the zone is unknown/unset, because
 * Luxon doesn't officially support "unset" zones.
 */
exports.UnsetZone = luxon_1.Info.normalizeZone(exports.UnsetZoneOffsetMinutes);
/**
 * Zone instances with this name are a placeholder for being "unset".
 */
exports.UnsetZoneName = exports.UnsetZone.name;
/**
 * If `tzSource` matches this value, the tags are from a video, and we had to
 * resort to assuming time fields are in UTC.
 * @see https://github.com/photostructure/exiftool-vendored.js/issues/113
 */
exports.defaultVideosToUTC = "defaultVideosToUTC";
function normalizeZone(z) {
    try {
        if (z == null || (0, String_1.blank)(String(z)))
            return;
        const zone = luxon_1.Info.normalizeZone(z);
        return (zone === null || zone === void 0 ? void 0 : zone.isValid) === true ? zone : undefined;
    }
    catch {
        return;
    }
}
exports.normalizeZone = normalizeZone;
function reasonableTzOffsetMinutes(tzOffsetMinutes) {
    return ((0, Number_1.isNumber)(tzOffsetMinutes) &&
        tzOffsetMinutes !== exports.UnsetZoneOffsetMinutes &&
        Math.abs(tzOffsetMinutes) < exports.MaxTzOffsetHours * 60);
}
exports.reasonableTzOffsetMinutes = reasonableTzOffsetMinutes;
/**
 * Returns a "zone name" (used by `luxon`) that encodes the given offset.
 */
function offsetMinutesToZoneName(offsetMinutes) {
    if (offsetMinutes == null ||
        !(0, Number_1.isNumber)(offsetMinutes) ||
        offsetMinutes === exports.UnsetZoneOffsetMinutes) {
        return undefined;
    }
    if (offsetMinutes === 0)
        return "UTC";
    const sign = offsetMinutes < 0 ? "-" : "+";
    const absMinutes = Math.abs(offsetMinutes);
    if (absMinutes > exports.MaxTzOffsetHours * 60)
        return undefined;
    const hours = Math.floor(absMinutes / 60);
    const minutes = Math.abs(absMinutes % 60);
    // luxon now renders simple hour offsets without padding:
    return `UTC${sign}` + hours + (minutes === 0 ? "" : `:${(0, String_1.pad2)(minutes)}`);
}
exports.offsetMinutesToZoneName = offsetMinutesToZoneName;
function tzHourToOffset(n) {
    return (0, Number_1.isNumber)(n) && reasonableTzOffsetMinutes(n * 60)
        ? offsetMinutesToZoneName(n * 60)
        : undefined;
}
const utcTzRe = /(?:UTC)?(?<sign>[+-]?)(?<hours>\d\d?)(?::(?<minutes>\d\d))?/;
const timestampTzRe = /(?<sign>[+-])(?<hours>\d\d?):(?<minutes>\d\d)$/;
function extractOffsetFromHours(hourOffset) {
    return (0, Number_1.isNumber)(hourOffset)
        ? (0, Maybe_1.map)(tzHourToOffset(hourOffset), (tz) => ({
            tz,
            src: "hourOffset",
        }))
        : Array.isArray(hourOffset)
            ? extractOffsetFromHours(hourOffset[0])
            : undefined;
}
/**
 * Parse a timezone offset and return the offset minutes
 */
function extractOffset(value) {
    var _a, _b, _c, _d, _e;
    if (value instanceof ExifDateTime_1.ExifDateTime) {
        return (0, Maybe_1.map)(value.zone, (tz) => ({ tz, src: "ExifDateTime" }));
    }
    if ((0, Number_1.isNumber)(value) || Array.isArray(value)) {
        return extractOffsetFromHours(value);
    }
    if ((0, String_1.isString)(value) && luxon_1.Info.isValidIANAZone(value)) {
        return { tz: value, src: "validIANAZone" };
    }
    // ExifTime will have a rawValue, but doesn't support zone extraction:
    const str = (_a = value.rawValue) !== null && _a !== void 0 ? _a : (0, String_1.toS)(value);
    if ((0, String_1.blank)(str))
        return;
    for (const g of (0, Array_1.compact)([
        (_b = utcTzRe.exec(str)) === null || _b === void 0 ? void 0 : _b.groups,
        (_c = timestampTzRe.exec(str)) === null || _c === void 0 ? void 0 : _c.groups,
    ])) {
        const tz = offsetMinutesToZoneName((g.sign === "-" ? -1 : 1) *
            (parseInt((_d = g.hours) !== null && _d !== void 0 ? _d : "0") * 60 + parseInt((_e = g.minutes) !== null && _e !== void 0 ? _e : "0")));
        if (tz != null)
            return { tz, src: "offsetMinutesToZoneName" };
    }
    return;
}
exports.extractOffset = extractOffset;
const TimezoneOffsetTagnames = [
    "TimeZone",
    "OffsetTime",
    /** time zone for DateTimeOriginal, "-08:00" */
    "OffsetTimeOriginal",
    /** time zone for CreateDate, "-08:00" */
    "OffsetTimeDigitized",
    /**
     * 1 or 2 values: 1. The time zone offset of DateTimeOriginal from GMT in
     * hours, 2. If present, the time zone offset of ModifyDate (which we ignore)
     * @see https://www.exiftool.org/TagNames/EXIF.html
     */
    "TimeZoneOffset", // number | number[] | string
];
// The following are a hail-mary to try to get the offset from a
// created-at tag, and only examined if `inferTimezoneFromDatestamps` is
// true.
const CreateDateTagnames = [
    "SubSecCreateDate",
    "CreateDate",
    "SubSecDateTimeOriginal",
    "DateTimeOriginal",
    "SubSecMediaCreateDate",
    "MediaCreateDate",
    "CreationDate",
    "TimeCreated", // < IPTC tag
];
function extractTzOffsetFromTags(t, opts) {
    var _a;
    for (const tagName of [
        ...TimezoneOffsetTagnames,
        ...(((_a = opts === null || opts === void 0 ? void 0 : opts.inferTimezoneFromDatestamps) !== null && _a !== void 0 ? _a : false) ? CreateDateTagnames : []),
    ]) {
        if (t[tagName] != null) {
            const offset = extractOffset(t[tagName]);
            if (offset != null) {
                return { tz: offset.tz, src: tagName };
            }
        }
    }
    if (t.TimeZoneOffset != null) {
        const tz = tzHourToOffset(Array.isArray(t.TimeZoneOffset) ? t.TimeZoneOffset[0] : t.TimeZoneOffset);
        if (tz != null)
            return {
                tz,
                src: "TimeZoneOffset",
            };
    }
    return;
}
exports.extractTzOffsetFromTags = extractTzOffsetFromTags;
// timezone offsets may be on a 15 minute boundary, but if GPS acquisition is
// old, this can be spurious. We get less mistakes with a larger multiple, so
// we're using 30 minutes instead of 15. See
// https://www.timeanddate.com/time/time-zones-interesting.html
const TzBoundaryMinutes = 30;
function inferLikelyOffsetMinutes(deltaMinutes) {
    return TzBoundaryMinutes * Math.floor(deltaMinutes / TzBoundaryMinutes);
}
exports.inferLikelyOffsetMinutes = inferLikelyOffsetMinutes;
function extractTzOffsetFromUTCOffset(t) {
    var _a;
    const gpsStamps = (0, Array_1.compact)([t.GPSDateStamp, t.GPSTimeStamp]);
    if (gpsStamps.length === 2) {
        (_a = t.GPSDateTimeStamp) !== null && _a !== void 0 ? _a : (t.GPSDateTimeStamp = gpsStamps.join(" "));
    }
    // We can always assume these are in UTC:
    const utc = (0, Maybe_1.first)(["GPSDateTime", "DateTimeUTC", "GPSDateTimeStamp"], (tagName) => {
        var _a;
        const edt = ExifDateTime_1.ExifDateTime.fromExifStrict(t[tagName]);
        const s = edt != null && (edt.zone == null || edt.zone === "UTC")
            ? (_a = edt.setZone("UTC", { keepLocalTime: true })) === null || _a === void 0 ? void 0 : _a.toEpochSeconds()
            : undefined;
        return s != null
            ? {
                tagName,
                s,
            }
            : undefined;
    });
    if (utc == null)
        return;
    // If we can find any of these without a zone, the timezone should be the
    // offset between this time and the GPS time.
    const dt = (0, Maybe_1.first)(CapturedAtTagNames_1.CapturedAtTagNames, (tagName) => {
        var _a;
        const edt = ExifDateTime_1.ExifDateTime.fromExifStrict(t[tagName]);
        const s = edt != null && edt.zone == null
            ? (_a = edt.setZone("UTC", { keepLocalTime: true })) === null || _a === void 0 ? void 0 : _a.toEpochSeconds()
            : undefined;
        return s != null
            ? {
                tagName,
                s,
            }
            : undefined;
    });
    if (dt == null)
        return;
    const diffSeconds = dt.s - utc.s;
    const offsetMinutes = inferLikelyOffsetMinutes(diffSeconds / 60);
    return (0, Maybe_1.map)(offsetMinutesToZoneName(offsetMinutes), (tz) => ({
        tz,
        src: `offset between ${dt.tagName} and ${utc.tagName}`,
    }));
}
exports.extractTzOffsetFromUTCOffset = extractTzOffsetFromUTCOffset;
function equivalentZones(a, b) {
    const az = normalizeZone(a);
    const bz = normalizeZone(b);
    return (az != null &&
        bz != null &&
        (az.equals(bz) || az.offset(Date.now()) === bz.offset(Date.now())));
}
exports.equivalentZones = equivalentZones;
//# sourceMappingURL=Timezones.js.map