"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var _ExifDateTime_dt;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExifDateTime = void 0;
const luxon_1 = require("luxon");
const DateTime_1 = require("./DateTime");
const Maybe_1 = require("./Maybe");
const Object_1 = require("./Object");
const String_1 = require("./String");
const Timezones_1 = require("./Timezones");
/**
 * Encodes an ExifDateTime with an optional tz offset in minutes.
 */
class ExifDateTime {
    constructor(year, month, day, hour, minute, second, millisecond, tzoffsetMinutes, rawValue, zoneName) {
        this.year = year;
        this.month = month;
        this.day = day;
        this.hour = hour;
        this.minute = minute;
        this.second = second;
        this.millisecond = millisecond;
        this.tzoffsetMinutes = tzoffsetMinutes;
        this.rawValue = rawValue;
        this.zoneName = zoneName;
        _ExifDateTime_dt.set(this, void 0);
    }
    static fromISO(iso, zone) {
        if ((0, String_1.blank)(iso) || null != iso.match(/^\d+$/))
            return undefined;
        // Unfortunately, DateTime.fromISO() is happy to parse a date with no time,
        // so we have to do this ourselves:
        return this.fromPatterns(iso, [
            // if it specifies a zone, use it:
            { fmt: "y-M-d'T'H:m:s.uZZ" },
            { fmt: "y-M-d'T'H:m:sZZ" },
            // if it specifies UTC, use it:
            { fmt: "y-M-d'T'H:m:s.u'Z'", zone: "utc" },
            { fmt: "y-M-d'T'H:m:s'Z'", zone: "utc" },
            // Otherwise use the default zone:
            { fmt: "y-M-d'T'H:m:s.u", zone },
            { fmt: "y-M-d'T'H:m:s", zone },
        ]);
    }
    /**
     * Try to parse a date-time string from EXIF. If there is not both a date and
     * a time component, returns `undefined`.
     *
     * @param text from EXIF metadata
     * @param defaultZone a "zone name" which may be IANA, like
     * "America/Los_Angeles", or an offset, like "UTC-3". See
     * `offsetMinutesToZoneName`.
     */
    static fromEXIF(text, defaultZone) {
        if ((0, String_1.blank)(text))
            return undefined;
        return (0, Maybe_1.firstDefinedThunk)([
            () => this.fromExifStrict(text, defaultZone),
            () => this.fromISO(text, defaultZone),
            () => this.fromExifLoose(text, defaultZone),
        ]);
    }
    static fromPatterns(text, fmts) {
        const s = (0, String_1.toS)(text).trim();
        const inputs = [s];
        // Some EXIF datetime will "over-specify" and include both the utc offset
        // *and* the "time zone abbreviation", like PST or PDT.
        // TZAs are between 2 (AT) and 5 (WEST) characters.
        // Unfortunately, luxon doesn't support regex.
        // We only want to strip off the TZA if it isn't "UTC" or "Z"
        if (null == s.match(/[.\d\s](utc|z)$/i)) {
            const noTza = s.replace(/ [a-z]{2,5}$/i, "");
            if (noTza !== s)
                inputs.push(noTza);
        }
        return (0, Maybe_1.first)(inputs, (input) => (0, Maybe_1.first)(fmts, ({ fmt, zone }) => (0, Maybe_1.map)(luxon_1.DateTime.fromFormat(input, fmt, {
            setZone: true,
            zone: zone !== null && zone !== void 0 ? zone : Timezones_1.UnsetZone,
        }), (dt) => this.fromDateTime(dt, s))));
    }
    static fromExifStrict(text, zone) {
        var _a;
        if ((0, String_1.blank)(text))
            return undefined;
        return ((_a = this.fromPatterns(text, [
            // if it specifies a zone, use it:
            { fmt: "y:M:d H:m:s.uZZ" },
            { fmt: "y:M:d H:m:sZZ" },
            // if it specifies UTC, use it:
            { fmt: "y:M:d H:m:s.u'Z'", zone: "utc" },
            { fmt: "y:M:d H:m:s'Z'", zone: "utc" },
            // Otherwise use the default zone:
            { fmt: "y:M:d H:m:s.u", zone },
            { fmt: "y:M:d H:m:s", zone },
            // Not found yet? Maybe it's in ISO format? See https://github.com/photostructure/exiftool-vendored.js/issues/71
        ])) !== null && _a !== void 0 ? _a : this.fromISO(text, zone));
    }
    static fromExifLoose(text, defaultZone) {
        if ((0, String_1.blank)(text))
            return undefined;
        const zone = (0, String_1.notBlank)(defaultZone) ? defaultZone : Timezones_1.UnsetZone;
        return this.fromPatterns(text, [
            // FWIW, the following are from actual datestamps seen in the wild:
            { fmt: "MMM d y H:m:sZZZ" },
            { fmt: "MMM d y H:m:s", zone },
            { fmt: "MMM d y, H:m:sZZZ" },
            { fmt: "MMM d y, H:m:s", zone },
            // Thu Oct 13 00:12:27 2016:
            { fmt: "ccc MMM d H:m:s yZZ" },
            { fmt: "ccc MMM d H:m:s y", zone },
        ]);
    }
    static fromDateTime(dt, rawValue) {
        var _a;
        if (dt == null ||
            !dt.isValid ||
            dt.toMillis() === 0 ||
            dt.year === 0 ||
            dt.year === 1) {
            return undefined;
        }
        return new ExifDateTime(dt.year, dt.month, dt.day, dt.hour, dt.minute, dt.second, dt.millisecond, dt.offset === Timezones_1.UnsetZoneOffsetMinutes ? undefined : dt.offset, rawValue, ((_a = dt.zone) === null || _a === void 0 ? void 0 : _a.name) === Timezones_1.UnsetZone.name ? undefined : dt.zoneName);
    }
    /**
     * Create an ExifDateTime from a number of milliseconds since the epoch
     * (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
     *
     * @param millis - a number of milliseconds since 1970 UTC
     *
     * @param options.rawValue - the original parsed string input
     * @param options.zone - the zone to place the DateTime into. Defaults to 'local'.
     * @param options.locale - a locale to set on the resulting DateTime instance
     * @param options.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param options.numberingSystem - the numbering system to set on the resulting DateTime instance
     */
    static fromMillis(millis, options = {}) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.fromDateTime(luxon_1.DateTime.fromMillis(millis, (0, Object_1.omit)(options, "rawValue")), options.rawValue);
    }
    static now(opts = {}) {
        return this.fromMillis(Date.now(), opts);
    }
    get millis() {
        return this.millisecond;
    }
    get hasZone() {
        return (0, String_1.notBlank)(this.zone);
    }
    get zone() {
        var _a;
        return (_a = this.zoneName) !== null && _a !== void 0 ? _a : (0, Timezones_1.offsetMinutesToZoneName)(this.tzoffsetMinutes);
    }
    setZone(zone, opts) {
        // This is a bit tricky... We want to keep the local time and just _say_ it was in the zone of the image **if we don't already have a zone.**
        // If we _do_ have a zone, assume it was already converted by ExifTool into (probably the system) timezone, which means _don't_ keepLocalTime.
        const result = ExifDateTime.fromDateTime(this.toDateTime().setZone(zone, {
            keepLocalTime: !this.hasZone,
            ...opts,
        }), this.rawValue);
        // We know this will be defined: this is valid, so changing the zone will
        // also be valid.
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return result;
    }
    toDateTime() {
        var _a;
        return (__classPrivateFieldSet(this, _ExifDateTime_dt, (_a = __classPrivateFieldGet(this, _ExifDateTime_dt, "f")) !== null && _a !== void 0 ? _a : luxon_1.DateTime.fromObject({
            year: this.year,
            month: this.month,
            day: this.day,
            hour: this.hour,
            minute: this.minute,
            second: this.second,
            millisecond: this.millisecond,
        }, {
            zone: this.zone,
        }), "f"));
    }
    toEpochSeconds() {
        return this.toDateTime().toUnixInteger();
    }
    toDate() {
        return this.toDateTime().toJSDate();
    }
    toISOString(options = {}) {
        var _a;
        return (0, Maybe_1.denull)(this.toDateTime().toISO({
            suppressMilliseconds: (_a = options.suppressMilliseconds) !== null && _a !== void 0 ? _a : this.millisecond == null,
            includeOffset: this.hasZone && options.includeOffset !== false,
        }));
    }
    toExifString() {
        return (0, DateTime_1.dateTimeToExif)(this.toDateTime());
    }
    toString() {
        return this.toISOString();
    }
    get isValid() {
        return this.toDateTime().isValid;
    }
    toJSON() {
        return {
            _ctor: "ExifDateTime",
            year: this.year,
            month: this.month,
            day: this.day,
            hour: this.hour,
            minute: this.minute,
            second: this.second,
            millisecond: this.millisecond,
            tzoffsetMinutes: this.tzoffsetMinutes,
            rawValue: this.rawValue,
            zoneName: this.zoneName,
        };
    }
    static fromJSON(json) {
        return new ExifDateTime(json.year, json.month, json.day, json.hour, json.minute, json.second, json.millisecond, json.tzoffsetMinutes, json.rawValue, json.zoneName);
    }
}
exports.ExifDateTime = ExifDateTime;
_ExifDateTime_dt = new WeakMap();
//# sourceMappingURL=ExifDateTime.js.map