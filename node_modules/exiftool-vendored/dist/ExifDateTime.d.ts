import { DateTime, DateTimeJSOptions, ToISOTimeOptions, Zone, ZoneOptions } from "luxon";
import { Maybe } from "./Maybe";
/**
 * Encodes an ExifDateTime with an optional tz offset in minutes.
 */
export declare class ExifDateTime {
    #private;
    readonly year: number;
    readonly month: number;
    readonly day: number;
    readonly hour: number;
    readonly minute: number;
    readonly second: number;
    readonly millisecond?: number | undefined;
    readonly tzoffsetMinutes?: number | undefined;
    readonly rawValue?: string | undefined;
    readonly zoneName?: string | undefined;
    static fromISO(iso: string, zone?: Maybe<string>): Maybe<ExifDateTime>;
    /**
     * Try to parse a date-time string from EXIF. If there is not both a date and
     * a time component, returns `undefined`.
     *
     * @param text from EXIF metadata
     * @param defaultZone a "zone name" which may be IANA, like
     * "America/Los_Angeles", or an offset, like "UTC-3". See
     * `offsetMinutesToZoneName`.
     */
    static fromEXIF(text: string, defaultZone?: Maybe<string>): Maybe<ExifDateTime>;
    private static fromPatterns;
    static fromExifStrict(text: Maybe<string>, zone?: Maybe<string>): Maybe<ExifDateTime>;
    static fromExifLoose(text: Maybe<string>, defaultZone?: Maybe<string>): Maybe<ExifDateTime>;
    static fromDateTime(dt: DateTime, rawValue?: string): Maybe<ExifDateTime>;
    /**
     * Create an ExifDateTime from a number of milliseconds since the epoch
     * (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
     *
     * @param millis - a number of milliseconds since 1970 UTC
     *
     * @param options.rawValue - the original parsed string input
     * @param options.zone - the zone to place the DateTime into. Defaults to 'local'.
     * @param options.locale - a locale to set on the resulting DateTime instance
     * @param options.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param options.numberingSystem - the numbering system to set on the resulting DateTime instance
     */
    static fromMillis(millis: number, options?: DateTimeJSOptions & {
        rawValue?: string;
    }): ExifDateTime;
    static now(opts?: DateTimeJSOptions & {
        rawValue?: string;
    }): ExifDateTime;
    constructor(year: number, month: number, day: number, hour: number, minute: number, second: number, millisecond?: number | undefined, tzoffsetMinutes?: number | undefined, rawValue?: string | undefined, zoneName?: string | undefined);
    get millis(): number | undefined;
    get hasZone(): boolean;
    get zone(): Maybe<string>;
    setZone(zone?: string | Zone, opts?: ZoneOptions): ExifDateTime;
    toDateTime(): DateTime;
    toEpochSeconds(): number;
    toDate(): Date;
    toISOString(options?: ToISOTimeOptions): Maybe<string>;
    toExifString(): string;
    toString(): Maybe<string>;
    get isValid(): boolean;
    toJSON(): {
        _ctor: string;
        year: number;
        month: number;
        day: number;
        hour: number;
        minute: number;
        second: number;
        millisecond: number | undefined;
        tzoffsetMinutes: number | undefined;
        rawValue: string | undefined;
        zoneName: string | undefined;
    };
    static fromJSON(json: ReturnType<ExifDateTime["toJSON"]>): ExifDateTime;
}
